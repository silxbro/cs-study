# 트랜잭션
<br/>

트랜잭션(transaction)은 DBMS가 데이터베이스를 다룰 때 사용하는 작업(프로그램) 단위이다.
트랜잭션은 데이터베이스의 무결성을 유지하기 위해 원자성, 일관성, 고립성, 지속성의 성질을 갖는다. DBMS는 트랜잭션이 이러한 성질을 유지할 수 있도록 지원한다.
각 개념에 대해 하나씩 살펴보자.
<br/>
<br/>
## 1. 트랜잭션의 개념
트랜잭션(transaction)은 DBMS에서 데이터를 다루는 논리적인 작업의 단위이다. 보통 단일 SQL 문을 사용하여 다루기도 하지만 여러 개의 SQL 문을 순차적으로 수행하여 다루기도 한다.
데이터베이스에서 트랜잭션을 정의하는 이유는 다음과 같다.
- 데이터베이스에서 데이터를 다룰 때 장애가 일어나는 경우가 있다. 트랜잭션은 장애 발생 시 데이터를 복구하는 작업의 단위가 된다.
- 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때가 있다. 트랜잭션은 이 작업을 서로 분리하는 단위가 된다.

트랜잭션은 전체가 수행되거나 또는 전혀 수행되지 않아야 한다(all or nothing).
- 예를 들어 은행 업무를 보는데 A 계좌(박지성)에서 B 계좌(김연아)로 10,000원을 이체할 경우 프로그램은 다음과 같다.
  ```SQL
    BEGIN
      ① A 계좌(박지성)에서 10,000원을 인출하는 SQL UPDATE 문
      ② B 계좌(김연아)에서 10,000원을 입금하는 SQL UPDATE 문
    END
  ```
  만약 ①번 SQL 문이 수행된 다음 시스템에 문제가 생기거나 다른 UPDATE 문이 끼어들어 A 계좌에서 돈을 동시에 인출하면, A 계좌와 B 계좌의 잔액이 의도하지 않는 값이 될 수 있다.
  따라서 ①번 SQL 문과 ②번 SQL 문은 모두 수행되거나 아예 수행되지 않아야 한다.

만약 ①번 SQL 문을 수행한 다음 문제가 생겨 ②번 SQL 문을 수행할 수 없는 경우라면 ①번 SQL 문의 수행을 취소해야 한다.
DBMS에 ①번과 ②번의 SQL 문이 하나의 수행 단위라는 것을 알리기 위해 사용하는 문법은 다음과 같다. START TRANSACTION 문과 COMMIT 문을 사용하여 트랜잭션의 시작과 끝을 표시한다.
```SQL
  START TRANSACTION
① A 계좌(박지성)에서 10,000원을 인출하는 SQL UPDATE 문
② B 계좌(김연아)에 10,000원을 입금하는 SQL UPDATE 문
  COMMIT
```
위와 같이 작성하면 ①번과 ②번의 두 SQL 문은 하나의 논리적인 작업의 단위가 된다. DBMS는 이 두 문장이 모두 수행되거나 모두 수행되지 않도록 지원한다.

위 계좌이체 트랜잭션이 데이터베이스에서 실행될 때 일어나는 상황을 구체적으로 보면 아래와 같다.
여기서 중요한 점은 데이터베이스의 데이터는 하드디스크에 저장되어 있고, 처리를 위해서는 반드시 주기억장치 버퍼로 사본을 읽어와야 한다는 점이다.
다시 설명으로 돌아가서, 관련 예제 테이블의 스키마 구조는 다음과 같다. 테이블 이름은 Customer이고 고객 이름(name)과 예금액(balance)을 저장한다.
- 테이블 : Customer(name, balance)

#### [계좌이체 트랜잭션과 수행 과정]
<img src="https://github.com/silxbro/cs-study/assets/142463332/62a35c1d-47bf-4d2e-9dc1-76fb5da1078a" width="600" height="330"/><br/>

트랜잭션은 데이터베이스에 저장된 테이블을 읽어와 주기억장치 버퍼에 저장하고, 버퍼에 저장된 데이터를 수정한 후 최종적으로 데이터베이스에 다시 저장한다.
위 그림의 (a)의 사용자 프로그램에는 ③,④에 해당하는 문장밖에 없지만 실제 처리 과정에는 DBMS가 데이터를 읽고 쓰는 ①,②,⑤,⑥이 포함되어 있다. ①~⑥의 세부적인 과정은 다음과 같다.

- ① A 계좌(박지성)의 값을 하드디스크(데이터베이스)에서 주기억장치 버퍼로 읽어온다.
- ② B 계좌(김연아)의 값을 하드디스크(데이터베이스)에서 주기억장치 버퍼로 읽어온다.
- ③ A 계좌(박지성)에서 10,000원을 인출한 값을 저장한다.
- ④ B 계좌(김연아)에 10,000원을 입금한 값을 저장한다.
- ⑤ A 계좌(박지성)의 값을 주기억장치 버퍼에서 하드디스크(데이터베이스)에 기록한다.
- ⑥ B 계좌(김연아)의 값을 주기억장치 버퍼에서 하드디스크(데이터베이스)에 기록한다.
  <br/>

- 데이터베이스는 전원과 관계없이 값을 유지하기 위해 보조기억장치(HDD 등)에 저장된다.

COMMIT 문은 트랜잭션의 종료를 알리는 SQL 문이다.
앞의 트랜잭션을 보면 트랜잭션의 사실적인 종료는 ①~⑥이 완전히 끝난 후지만, DBMS는 ①~④까지 수행하고 사용자에게 완료 사실을 알린다. 그리고 나머지 ⑤,⑥은 DBMS가 책임지고 수행한다.
아래의 [방법 1]과 같은 구조이다.
이렇게 하는 이유는 DBMS가 동시에 많은 트랜잭션을 수행할 때, 각각의 트랜잭션이 하드디스크에 개별 접근하는 것을 피하고 DBMS가 일괄적으로 하드디스크에 접근하여 처리함으로써
사용자에게 빠른 응답성을 보장하기 위해서다. 학생들이 많이 경험하는 대학의 수강신청도 이러한 원리로 진행된다고 생각하면 이해하기 쉽다.
- [방법 1] ① - ② - ③ - ④ - COMMIT - ⑤ - ⑥

만약 ⑤, ⑥을 수행한 다음 COMMIT을 수행하면 [방법 2]와 같은 구조가 된다.
- [방법 2] ① - ② - ③ - ④ - ⑤ - ⑥ - COMMIT

DBMS는 [방법 1]을 택한다. 그 이유는 수행 결과를 데이터베이스에 기록하는 ⑤, ⑥의 과정은 시간이 많이 소요되고, 다른 트랜잭션이 또 Customer 테이블을 필요로 할 수 있기 때문이다.
즉 트랜잭션은 임시로 종료를 선언하고 실제 데이터베이스에 기록하는 것은 DBMS가 수행한다.

[방법 1]을 풀어쓰면 다음과 같다. 이는 트랜잭션의 실제 수행 과정과 같다.
- [방법 1] ① - ② - ③ - ④ - COMMIT(부분완료) - ⑤ - ⑥ - 완료

트랜잭션의 수행 과정을 그림으로 정리하면 다음과 같다. 트랜잭션은 '시작-수행-부분완료-완료'의 과정을 거쳐 진행된다.
부분완료는 트랜잭션의 종료를 사용자나 다른 트랜잭션에게 알리는 단계이다.
부분완료된 트랜잭션은 DBMS가 다른 트랜잭션의 작업 처리 상황을 봐가면서 변경 내용을 하드디스크에 기록한다. 기록이 끝나면 완료를 한다.
완료 후에는 다른 트랜잭션이 데이터를 자유롭게 사용할 수 있다.

#### [트랜잭션의 수행 과정]
<img src="https://github.com/silxbro/cs-study/assets/142463332/c75ce8b4-560f-4481-b3e7-64459ce550f3" width="600" height="65"/><br/>
<br/>
<br/>
## 2. 트랜잭션의 성질
트랜잭션은 일반 프로그램과 달리 데이터베이스에 저장된 데이터를 다루며 DBMS에 의해 처리된다. 트랜잭션과 프로그램의 차이점은 다음과 같다.

#### [트랜잭션과 프로그램의 차이점]
|구분|트랜잭션|프로그램|
|:---|:---|:---|
|**프로그램 구조**|START TRANSACTION<br/>...<br/>COMMIT|main()<br/>{<br/>...<br/>}|
|**다루는 데이터**|데이터베이스 저장 데이터|파일 저장 데이터&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
|**번역기**|DBMS|컴파일러|
|**성질**|원자성, 일관성, 고립성, 지속성|-|

컴퓨터 시스템 내에서 트랜잭션과 프로그램의 차이를 그림으로 보면 다음과 같다. 트랜잭션은 데이터베이스에 저장된 데이터를 다루며 DBMS에 의해 처리된다.
반면 프로그램은 파일에 저장된 데이터를 다루며 DBMS 없이 직접 데이터를 처리한다.
- 프로그램이 데이터베이스를 다루는 경우도 있는데, 프로그램 내부에 SQL 문을 삽입하여 트랜잭션을 호출하는 형태이다.

#### [컴퓨터 시스템 내의 트랜잭션과 프로그램]
<img src="https://github.com/silxbro/cs-study/assets/142463332/21ca9ea4-7184-45dc-99fc-62eafbdfc35a" width="480" height="200"/><br/>

다음은 트랜잭션의 네 가지 성질을 정리한 것이다. 영문 앞 글자를 따서 보통 ACID 성질이라고 부른다.
- **원자성**(Atomicity)
  - 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야(all or nothing) 한다.
- **일관성**(Consistency)
  - 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
- **고립성**(Isolation)
  - 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 한다.
- **지속성**(Durability)
  - 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.
    저장된 데이터베이스는 저장 직후 혹은 어느 때나 발생할 수 있는 정전, 장애, 오류에 영향을 받지 않아야 한다.

### 원자성
원자성(Atomicity)이란 트랜잭션이 원자처럼 더 이상 쪼개지지 않는 하나의 프로그램 단위로 동작해야 한다는 의미이다.
즉 일부만 수행되는 일이 없도록 전부 수행하거나 아예 수행하지 않아야(all or nothing) 한다.
SQL에서는 트랜잭션의 시작과 끝을 표시하기 위해 START TRANSACTION ... COMMIT 문을 사용한다.
트랜잭션 중간에 작업이 잘못되면 회복(recovery) 알고리즘을 이용하여 변경한 내용을 취소한다(자의적으로 트랜잭션을 취소하는 명령어 ROLLBACK을 사용하기도 한다).
COMMIT과 ROLLBACK 명령어는 트랜잭션 제어 명령어(TCL, Transaction Control Language)라고 한다.

아래 표는 MySQL에서 사용하는 트랜잭션 제어 명령어를 정리한 것이다.
#### [MySQL의 트랜잭션 제어 명령어(TCL)]
|표준 명령어|문법|설명|
|:---|:---|:---|
|START TRANSACTION|SET TRANSACTION|트랜잭션의 시작|
|COMMIT|COMMIT|트랜잭션의 종료|
|ROLLBACK|ROLLBACK {TO <savepoint>}|트랜잭션을 전체 혹은 <savepoint>까지 무효화시킴|
|SAVE|SAVEPOINT <identifier>|<savepoint>를 만듦|

#### [MySQL에서 트랜잭션의 시작과 끝]
트랜잭션의 시작을 알리는 표준 명령어는 'START TRANSACTION' 문이다.
MySQL에서는 ① 'SET TRANSACTION NAME <이름>' 혹은 ② 데이터를 변경하는 SQL 문이 나오면 자동으로 트랜잭션이 시작된다.
트랜잭션 종료의 경우 ① COMMIT 또는 ROLLBACK 문 혹은 ② DDL 문을 만날 때 자동으로 종료된다.

트랜잭션의 길이가 길면 트랜잭션의 중간 지점에 수정내용을 반영하는 포인트를 만드는데, 이를 SAVEPOINT(저장점)라고 한다.
트랜잭션이 잘못되어 처음부터 다시 실행해야 할 경우 트랜잭션의 처음이 아니라 SAVEPOINT까지 되돌아가면 트랜잭션 전체가 ROLLBACK 되는 것을 막을 수 있다.
SAVAEPOINT는 트랜잭션 안에 여러 개 만들 수 있다.

다음은 MySQL에서 트랜잭션을 선언하고 수행하는 예이다. 트랜잭션은 ROLLBACK 명령어를 이용하여 자의적으로 수행했던 명령문을 취소한다.
- 실습은 demo_madang_init.sql을 실행하여 자료를 초기화한 후 진행한다. 트랜잭션 실습에서는 블록 단위로 쿼리를 실행하면 좀 더 손쉽게 실습을 진행할 수 있다.
  - <img src="https://github.com/silxbro/cs-study/assets/142463332/34b300ad-caad-466e-bf57-4e9209b627d0" width="20" height="20"/> [Ctrl] + [Shift] + [Enter] : 스크립트 전체 순차 실행
  - <img src="https://github.com/silxbro/cs-study/assets/142463332/73ebe126-a25d-4e09-9ef3-1a1d13996a32" width="20" height="20"/> [Ctrl] + [Enter] : Query Block(';'으로 마무리된 쿼리 블록) 단위 실행

```SQL
START TRANSACTION;
INSERT INTO Book VALUE (99, '데이터베이스', '한빛', 25000);

SELECT bookname 'bookname1' FROM Book
  WHERE bookid=99;  /* 데이터베이스 */
SAVEPOINT a;

UPDATE Book SET bookname='데이터베이스 개론' WHERE bookid=99;
SELECT bookname 'bookname2' FROM Book
  WHERE bookid=99;  /* 데이터베이스 개론 */
SAVEPOINT b;

UPDATE Book SET bookname='데이터베이스 개론 및 실습' WHERE bookid=99;
SELECT bookname 'bookname3' FROM Book
  WHERE bookid=99;  /* 데이터베이스 개론 및 실습 */
ROLLBACK TO b;

SELECT bookname 'bookname4' FROM Book
  WHERE bookid=99;  /* 데이터베이스 개론 */

ROLLBACK TO a;
SELECT bookname 'bookname5' FROM Book
  WHERE bookid=99;  /* 데이터베이스 */
COMMIT;

START TRANSACTION;

UPDATE Book SET bookname='데이터베이스 개론 및 실습2' WHERE bookid=99;
SELECT bookname 'bookname6' FROM Book
  WHERE bookid=99;  /* 데이터베이스 개론 및 실습2 */
ROLLBACK;

SELECT bookname 'bookname7' FROM Book
  WHERE bookid=99;  /* 데이터베이스 */

DELETE FROM Book WHERE bookid=99;
COMMIT;
```

### 일관성
트랜잭션은 데이터베이스의 일관성(Consistency)을 유지해야 한다. 일관성은 테이블이 생성될 때 CREATE 문과 ALTER 문의 무결성 제약조건을 통해 명시된다.
트랜잭션은 이 조건에 따라 일관성을 유지한다. 다만 수행 중 일시적으로 일관성을 유지하지 못하는 상태가 있을 수 있다.
예를 들어 계좌이체 트랜잭션의 경우 일관성 조건은 'A계좌+B계좌=20만 원'이다.
그런데 A 계좌에서 만 원을 인출하여 B 계좌에 입금하기 전에는 총액이 일시적으로 19만원으로 줄어드는 '일관성 없는(inconsistent)' 상태가 된다.
트랜잭션이 종료된 후에는 'A계좌+B계좌=20만 원'이 된다.
- 무결성 제약조건이 명시되지 않은 데이터의 일관성을 유지하는 일은 프로그래머의 몫이다.
#### [데이터베이스 변경 중과 변경 후의 일관성]
<img src="https://github.com/silxbro/cs-study/assets/142463332/adf91beb-e700-40f4-8d67-745fa9f4b009" width="430" height="160"/><br/>


### 고립성
데이터베이스는 공유가 목적이기 때문에 여러 트랜잭션이 동시에 수행된다. 이때 각 트랜잭션은 다른 트랜잭션의 방해를 받지 않고 독립적으로 작업을 수행한다.
이렇게 여러 트랜잭션이 동시에 수행될 때 상호 간섭이나 데이터 충돌이 일어나지 않는 현상을 고립성(Isolation)이라고 한다.
고립성을 유지하기 위해서는 변경 중인 임시 데이터를 다른 트랜잭션이 읽거나 쓰려고 할 때 제어하는 작업이 필요하다.

아래 그림을 보면, 같은 시간대에 여러 트랜잭션이 같은 데이터를 다루고 있다. 시간 t1에서 보면 트랜잭션 2와 트랜잭션 3이 실행 중이며 테이블 B를 동시에 다루고 있다.
같은 데이터를 동시에 읽고 쓸 경우, 변경 중인 데이터를 다른 트랜잭션이 사용하면 데이터의 일관성이 훼손될 수 있다.
따라서 동시에 수행되는 트랜잭션이 같은 데이터를 가지고 충돌하지 않도록 제어하는 작업이 필요하다. 이 작업을 동시성 제어(concurrency control)라고 한다.
#### [트랜잭션의 동시 수행과 데이터 공유]
<img src="https://github.com/silxbro/cs-study/assets/142463332/f6b740ca-dfb4-4003-afef-70672f1a95b9" width="430" height="250"/><br/>

- 2절 : 기본적인 동시성 제어의 개념과 기법
- 3절 : 동시성 제어보다 완화된 방법으로, 트랜잭션 고립 수준(isolation level)에 따라 트랜잭션의 상호 간섭을 완화시키는 방법

### 지속성
트랜잭션이 정상적으로 완료 혹은 부분완료한 데이터는 반드시 데이터베이스에 기록되어야 한다. 이러한 성질을 트랜잭션의 지속성(Durability)이라고 한다.
DBMS 복구 시스템은 트랜잭션이 작업한 내용을 수시로 로그(log) 데이터베이스에 기록하였다가 문제가 발생하면 로그 파일을 이용하여 복구 작업을 수행한다.
즉 시스템이 멈추어도 트랜잭션 수행으로 변경된 내용은 디스크에 기록된다.

트랜잭션의 상태도는 아래와 같다. 트랜잭션은 수행을 완료하면 부분완료 혹은 실패 상태 중 하나가 된다.
DBMS는 부분완료 상태에서는 작업한 내용을 데이터베이스에 반영하고, 실패 상태에서는 작업한 내용을 취소한다.

#### [트랜잭션의 상태도]
<img src="https://github.com/silxbro/cs-study/assets/142463332/01c15d9e-b17b-4173-93fc-1b478dd6e2dc" width="550" height="180"/><br/>

- 부분완료
  - 트랜잭션 수행은 완료되었지만 변경 내용이 데이터베이스에 기록되었는지 확실하지 않은 상태이다.
    이 상태에서는 DBMS가 최종적으로 변경 내용을 데이터베이스에 기록해야 완료(committed) 상태가 된다.
    만약 시스템 내부의 문제 혹은 시스템 다운 등으로 DBMS가 변경 내용을 데이터베이스에 기록하지 못하면 실패(failed) 상태가 된다.
- 실패
  - 트랜잭션을 중간에 중단하였거나 부분완료 상태에서 변경 내용을 데이터베이스에 저장하지 못한 상태를 말한다.
    실패 상태에서 DBMS는 트랜잭션이 수행한 작업을 모두 원상복구시킨다.
    <br/>

## 3. 트랜잭션과 DBMS
DBMS는 트랜잭션이 원자성, 일관성, 고립성, 지속성을 유지할 수 있도록 지원한다. 먼저 원자성을 유지하기 위해 회복(복구) 관리자 프로그램을 작동시킨다.
회복 관리자 프로그램은 데이터베이스가 변경한 내용을 로그로 기록하고 있다가 트랜잭션에 문제가 생겼을 때 원래 상태로 되돌린다.

DBMS는 일관성을 유지하기 위해 무결성 제약조건을 활용한다. 트랜잭션 수행 시 데이터에 변경이 가해지면 미리 정의해 둔 무결성 제약조건을 검사하여 일관성이 깨지는 것을 막는다.
그런데 두 개의 트랜잭션이 동시에 수행될 때 트랜잭션 간에 간섭으로 일관성이 깨지는 현상은 무결성 제약조건을 검사하는 것으로 해결할 수 없다.
동시에 같은 데이터를 접근하는 트랜잭션들이 질서 있게 접근하여 데이터베이스의 일관성을 유지하도록 하기 위해서는 동시성 제어 알고리즘을 작동시켜야 한다.

DBMS는 고립성을 유지하기 위해 일관성을 유지하는 것과 마찬가지로 동시성 제어 알고리즘을 작동시킨다.
두 개의 트랜잭션이 동시에 수행될 때 간섭에 의하여 데이터 값이 손상되면 고립성이 깨진다.
이 경우 동시성 제어 알고리즘을 작동시켜 여러 트랜잭션이 동시에 같은 데이터를 접근할 때 마치 한 트랜잭션씩 순서대로 접근하는 것처럼 제어한다.

DBMS는 지속성을 유지하기 위해 회복 관리자 프로그램을 이용한다.
회복 관리자 프로그램은 데이터베이스가 변경한 내용을 로그로 기록하고 있다가 트랜잭션에 문제가 있을 때 원래 상태로 되돌린다.

트랜잭션의 4가지 성질과 각 성질을 유지시키는 DBMS의 기능을 그림으로 나타내면 다음과 같다.

#### [트랜잭션의 성질과 DBMS의 기능]
<img src="https://github.com/silxbro/cs-study/assets/142463332/e65dd67c-5c09-41d0-8603-24356511d2f0" width="350" height="160"/><br/>