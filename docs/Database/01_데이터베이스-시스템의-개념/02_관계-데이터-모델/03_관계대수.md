# 관계대수
<br/>

릴레이션에서 데이터를 추출하는 데 사용하는 언어인 관계대수에 대해 살펴보자.

코드(Codd) 박사는 관계대수(relational algebra)와 관계해석(relational calculus)을 **관계 데이터 모델을 사용하는데 필요한 언어**로 소개했다.<br/>
**관계대수**는 어떤 데이터를 어떻게 찾는지에 대한 처리 절차를 명시하는 **절차적**인 언어이며, DBMS 내부의 처리 언어로 사용된다.<br/>
**관계해석**은 어떤 데이터를 찾는지만 명시하는 **선언적**인 언어로 관계대수와 함께 관계 DBMS의 표준 언어인 SQL의 이론적인 기반을 제공한다.<br/>
관계대수와 관계해석은 모두 관계 데이터 모델의 중요한 언어이며 실제 동일한 표현 기능이 있다.

관계 데이터베이스를 사용할 때 어떤 데이터를 어떻게 찾는지 알고 있는 것이 향후 데이터를 검색하고 관리하는 데 중요하다.
따라서 이 절에서는 관계해석에 대해서는 다루지 않고 관계대수에 대해서만 알아본다.
<br/>
<br/>
## 1. 관계대수
관계대수(relational algebra, 關係代數)란 릴레이션에서 원하는 결과를 얻기 위해 수학의 대수와 같은 연산을 이용하여 질의하는 방법을 기술하는 언어이다.
관계대수는 절차적 언어로, 하나 이상의 릴레이션에 연산을 수행하여 결과 릴레이션이 나오기까지의 절차를 확인할 수 있는 방법을 제공한다.
SQL 언어는 관계해석을 기반으로 하지만(정확하게는 관계대수 개념 역시 혼합되어 있다) DBMS 내부에서는 관계대수에 기반을 둔 연산을 수행하여 최종 결과 집합을 반환하게 된다.
- 관계대수의 대수(代數)는 수학의 대수학에서 사용되는 용어이다.
  대수학은 대수(代數, 수를 대신함)라는 명칭 그대로 수를 대신해서 문자를 사용하는 방법으로, 방정식을 푸는 방법을 연구하는 학문이다.

### 관계의 수학적 의미
관계 데이터베이스는 릴레이션(relation)이라는 수학적 개념에 기초한다. 수학적 의미의 릴레이션을 알아보고 데이터베이스에 어떻게 적용되는지 살펴보자.

집합은 숫자, 사람, 문자 등 객체의 모임이다. 두 개의 집합 A={2, 4}, B={1, 3, 5}가 있다고 하자. 두 집합의 카티전 프로덕트 A⨉B는 A 원소와 B 원소의 순서쌍의 집합이다.
즉, A⨉B={(2, 1), (2, 3), (2, 5), (4, 1), (4, 3), (4, 5)}를 말한다. 릴레이션 R은 카티전 프로덕트의 부분집합으로 정의한다.
R1={(2, 1), (4, 1)}도 하나의 릴레이션이고, R2={(2, 1), (2, 3), (2, 5)}도 릴레이션이며, R3={(2, 3), (2, 5), (4, 3), (4, 5)}도 릴레이션이다.
카티전 프로덕트 A⨉B에서 만들어질 수 있는 릴레이션은 많다. 원소 개수가 n인 집합 S의 부분집합의 개수는 2^n이므로, 카티전 프로덕트 A⨉B의 부분집합의 개수는 2^(|A|⨉|B|)이다.
예의 경우 |A|=2, |B|=3이므로 2^6=64개의 릴레이션이 가능하다.

세 개의 집합 A={2, 4}, B={1, 3, 5}, C={6, 7}이 있다고 하자. 카티전 프로덕트 A⨉B⨉C는 {(2, 1, 6), (2, 1, 7), (2, 3, 6), (2, 3, 7), ..., (4, 5, 7)}이며 원소의 개수는 12개이다.
또 카티전 프로덕트 A⨉B⨉C에서 만들어질 수 있는 부분집합(릴레이션)의 개수는 2^12이다.
예를 들어 릴레이션 R4={(2, 1, 7), (4, 1, 6), (4, 5, 7)}은 카티전 프로덕트 A⨉B⨉C의 부분집합으로 2^12개의 릴레이셔녀 중 하나이다.

카티전 프로덕트의 기초 집합 A, B, C 각각이 가질 수 있는 값의 범위를 도메인(domain)이라고 한다. 즉 집합 A의 도메인은 {2, 4}이다.

릴레이션은 카티전 프로덕트의 부분집합이라고 하였는데, 릴레이션 역시 집합이다. 릴레이션 R1={(2, 1), (4, 1)}이 집합이고, R2={(2, 1), (2, 3), (2, 5)}도 집합이다.
집합에서 가능한 연산은 합집합(⋃), 교집합(⋂), 카티전 프로덕트(⨉) 등이 있다.

```
  R1 ⋃ R2 = {(2, 1), (4, 1), (2, 3), (2, 5)}
  R1 ⋂ R2 = {(2, 1)}
```

지금까지 수학에서 정의하는 릴레이션을 설명했다. 데이터베이스에서 릴레이션은 수학의 릴레이션 개념을 현실 세계에 적용한 것이다. 현실 세계는 많은 문자 데이터를 포함한다.
예를 들어 두 집합 학번={2, 4}, 과목={데이터베이스, 자료구조, 프로그래밍}이 있다고 하자. 두 집합의 카티전 프로덕트 학번⨉과목은 학번 원소와 과목 원소의 순서쌍의 집합이다.
즉, 학번⨉과목={(2, 데이터베이스), (2, 자료구조), (2, 프로그래밍), (4, 데이터베이스), (4, 자료구조), (4, 프로그래밍)}을 말한다.
학번⨉과목의 각 원소는 학생이 과목을 수강할 수 있는 모든 경우를 나열한 것이다.
수강={(2, 데이터베이스), (2, 자료구조), (4, 프로그래밍)}은 카티전 프로덕트 학번⨉과목의 부분집합으로 하나의 릴레이션 인스턴스이다.
이 릴레이션을 테이블로 그리면 다음과 같다. 수강 릴레이션의 튜플은 위에서 나열한 여섯 개 원소 중 하나이다. 아래 수강 테이블을 데이터베이스에서는 릴레이션(relation)이라고 부른다.
#### [수강 릴레이션]
|학번|과목|
|:---|:---|
|2|데이터베이스|
|2|자료구조|
|4|프로그래밍|

### 관계대수 연산자
수학에서 연산자(operator)란 피연산자에 적용되는 연산 기호를 말한다.
예를 들어 2+3에서 2와 3은 피연산자고, + 기호는 연산자며, 피연산자를 연산자에 적용한 2+3의 결과는 5라고 약속한다.

관계대수 연산자 역시 **릴레이션 연산에 사용되는 기호**로 릴레이션을 피연산자로 한다.

관계대수 연산자는 대략 두 개의 그룹으로 나눌 수 있다.
첫째는 관계 데이터 모델을 위해 고안된 순수 관계 연산(relational operations)에 사용되는 연산자이며, 둘째는 수학의 집합이론에서 차용된 일반 집합 연산(set operations)에
사용되는 연산자이다. 각각의 종류를 살펴보면 다음과 같다.
- **순수 관계 연산** : 셀렉션(selection), 프로덕션(production), 조인(join), 디비전(division), 개명(rename)
- **일반 집합 연산** : 합집합(union), 차집합(difference), 교집합(intersection), 카티전 프로덕트(cartesian product)

연산자 중 피연산자의 개수가 한 개인 연산자를 단항 연산자(unary operator), 두 개인 연산자를 이항 연산자(binary operator)라고 한다.
또 관계대수 연산자는 기본 연산자 다섯 개와 기본 연산자로부터 유도가 가능한 유도 연산자로 구분한다.

#### [관계 대수 연산자]
|연산자 종류|대상|연산자 이름|기호|설명|
|:---|:---|:---|:---:|:---|
|기본|단항|셀렉션|σ|릴레이션에서 조건에 만족하는 튜플을 선택|
|기본|단항|프로젝션|π|릴레이션의 속성을 선택|
|추가|단항|개명|ρ|릴레이션이나 속성의 이름을 변경|
|유도|이항|디비전|÷|부모 릴레이션에 포함된 튜플의 값을 모두 갖고 있는<br/>튜플을 분자 릴레이션에서 추출|
|기본|이항|합집합|⋃|두 릴레이션의 합집합|
|기본|이항|차집합|–|두 릴레이션의 차집합|
|유도|이항|교집합|⋂|두 릴레이션의 교집합|
|기본|이항|카티전 프로덕트|⨉|두 릴레이션에 속한 모든 튜플의 집합|
|유도|이항|세타 조인|<img src="https://github.com/silxbro/cs-study/assets/142463332/2f222eb1-4a47-4dd5-a63a-b6189fa24af8" width="20" height="10"/><br/>|두 릴레이션 간의 비교 조건에 만족하는 집합|
|유도|이항|동등 조인|⨝|두 릴레이션 간의 같은 값을 가진 집합|
|유도|이항|자연 조인|<img src="https://github.com/silxbro/cs-study/assets/142463332/81c0ebaa-7fce-430c-a076-56526f7aa00f" width="20" height="10"/><br/>|동등조인에서 중복 속성을 제거|
|유도|이항|세미 조인 (왼쪽)|<img src="https://github.com/silxbro/cs-study/assets/142463332/f8980833-c2f6-4831-9411-9e19eb82ff26" width="15" height="10"/><br/>|자연조인 후 오른쪽 속성을 제거|
|유도|이항|세미 조인 (오른쪽)|<img src="https://github.com/silxbro/cs-study/assets/142463332/c8aac3a7-6ac8-4c99-bd86-c8c1a817a013" width="15" height="10"/><br/>|자연조인 후 왼쪽 속성을 제거|
|유도|이항|외부 조인 (왼쪽)<br/>외부 조인 (오른쪽)<br/>외부 조인 (양쪽)|<img src="https://github.com/silxbro/cs-study/assets/142463332/9d63e78d-70d7-499d-a456-52ca065995a7" width="15" height="10"/><br/><img src="https://github.com/silxbro/cs-study/assets/142463332/2be9999e-4420-4ee2-ba99-5e2d9b39e85a" width="15" height="10"/><br/><img src="https://github.com/silxbro/cs-study/assets/142463332/ee904c10-cead-43b3-af54-92173d77ba69" width="20" height="10"/>|- 자연조인 후 각각 왼쪽(left), 오른쪽(right), 양쪽(full)의<br>&nbsp;&nbsp;&nbsp;모든 값을 결과로 추출<br/>- 조인이 실패(또는 값이 없을 경우)한 쪽의 값을<br/>&nbsp;&nbsp;&nbsp;NULL로 채움|

### 관계대수식
관계대수는 릴레이션 간 연산을 통해 결과 릴레이션을 찾는 절차를 기술한 언어이다. 관계대수 연산을 수행하기 위한 식을 관계대수식(relational algebra expression)이라고 한다.
관계대수식은 대상이 되는 릴레이션과 연산자로 구성된다. 관계대수식의 적용 순서는 수학의 연산과 동일하게 괄호() 안의 식이 우선하며 왼쪽에서 오른쪽으로 진행된다.
기본적인 형태는 다음과 같다.
```
- 단항 연산자 : 연산자<조건> 릴레이션
- 이항 연산자 : 릴레이션1 연산자<조건> 릴레이션2
```
- 연산자와 같이 사용되는 <조건>은 혼란을 피하기 위해 아래 첨자로 표시한다.

관계대수식의 결과는 릴레이션으로 반환되며, 반환된 릴레이션은 릴레이션의 모든 특징을 따른다. 즉 중복된 튜플은 존재하지 않는다. 만약 중복된 튜플이 있을 경우 하나만 표시한다.
다음 그림은 관계대수식을 이해하기 위한 예제 데이터이다. 릴레이션 R1과 릴레이션 R2로 구성되어 있고, 관계대수식의 결과는 아래 표를 통해 알 수 있다.

#### [관계대수식을 이해하기 위한 예제 데이터]
<img src="https://github.com/silxbro/cs-study/assets/142463332/e8108d96-55b5-4a4a-b64b-531ba7192880" width="250" height="130"/><br/>

#### [관계대수식의 사용 예]
|주요 연산자|사용 예|결과|설명|
|:---|:---|:---|:---|
|셀렉션(σ)|<img src="https://github.com/silxbro/cs-study/assets/142463332/60f05647-ef87-483b-ad02-2e1581c5153e" width="100" height="15"/><br/>|<img src="https://github.com/silxbro/cs-study/assets/142463332/9a4e334a-3162-483f-b4bd-8f22e14f0adf" width="100" height="75"/><br/>|R1에서 조건에 맞는 튜플을 추출한다.|
|프로젝션(π)|<img src="https://github.com/silxbro/cs-study/assets/142463332/d72a2a3c-6793-472a-80ad-1d730b17e46d" width="60" height="15"/><br/>|<img src="https://github.com/silxbro/cs-study/assets/142463332/4b08bcb7-0494-42e7-a25e-f2714d360a70" width="70" height="100"/><br/>|R2에서 조건에 맞는 속성만을 추출한다.|
|합집합(⋃)|R1 ⋃ R2|<img src="https://github.com/silxbro/cs-study/assets/142463332/19cfd393-31ac-4773-8e40-d8ee63748a01" width="100" height="125"/><br/>|R1과 R2의 합집합을 구한다.|
|차집합(–)|R1 – R2|<img src="https://github.com/silxbro/cs-study/assets/142463332/e4d5427b-fbb6-4450-ba2d-a8f747947080" width="100" height="50"/><br/>|R1과 R2의 차집합을 구한다.|
|조인(⨝)|<img src="https://github.com/silxbro/cs-study/assets/142463332/53827f85-2042-4319-8ea7-b6445d063fac" width="120" height="12"/><br/>|<img src="https://github.com/silxbro/cs-study/assets/142463332/a7c55924-2a8f-4774-918c-510c5042c5da" width="200" height="100"/><br/>|R1과 R2의 카티전 프로덕트를 수행한 후<br/>조건에 맞는 튜플을 추출한다.|
<br/>

## 2. 셀렉션과 프로젝션
셀렉션과 프로젝션은 관계대수에서 가장 기본적인 연산으로 하나의 릴레이션을 대상으로 하는 단항 연산자이다.
연산의 결과 역시 하나의 릴레이션인데, 셀렉션은 대상 릴레이션에서 인스턴스의 일부 즉 튜플의 집합을 반환하며 프로젝션은 대상 릴레이션에서 지정된 속성 값의 일부를 반환한다.
두 연산 모두 관계대수 연산을 위해 고안된 순수 관계 연산자이다.

### 셀렉션
셀렉션(selection)은 단어 그대로 릴레이션의 튜플을 추출하기 위한 연산이다.
하나의 릴레이션을 대상으로 하는 단항 연산자이며, 찾고자 하는 튜플의 조건(predicate)을 명시하고 그 조건에 만족하는 튜플을 반환한다.
결과 릴레이션의 차수는 대상 릴레이션과 동일하고 카디널리티는 대상 릴레이션보다 작거나 같다. 조건으로는 `<속성>=<상수값 또는 속성>` 형태가 올 수 있다.
작성 형식은 다음과 같다. R은 릴레이션을 나타낸다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/c7671486-c24b-45bb-8bf2-bd0d4c53a396" width="100" height="25"/><br/>

#### [질의 2-1] 마당서점에서 판매하는 도서 중 8,000원 이하인 도서를 검색하시오.
-
<img src="https://github.com/silxbro/cs-study/assets/142463332/049f1504-2ba4-4297-9fb2-b63702bfa825" width="130" height="20"/><br/>

- 위 질의의 결과는 가격이 8,000원 이하인(가격<=8000) 도서만 찾아 추출한다.
  결과 릴레이션의 차수는 도서 릴레이션과 동일하므로 4이고, 카디날리티는 8,000원 이하인 도서가 두 권이 있으므로 2이다.

- 셀렉션의 예

  <img src="https://github.com/silxbro/cs-study/assets/142463332/4204284c-e931-4ffd-be58-58c1ac933ad4" width="360" height="320"/><br/>

만약 조건이 여러 개라면 ⋀(and), ⋁(or),﹁(not) 기호를 이용하여 표현할 수 있다.
- 예를 들어 '가격이 8,000원 이하이고 도서번호가 3이상인 도서'를 검색하려면 'σ 가격<=8000 ⋀ 도서번호>=3 (도서)'로 표현하면 된다.

### 프로젝션
프로젝션(projection)은 릴레이션의 속성을 추출하기 위한 연산으로 단항 연산자이다. 결과 릴레이션의 차수는 대상 릴레이션의 차수보다 작거나 같고 카디날리티는 동일하다.
작성 형식은 다음과 같다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/4925214d-f674-40b4-9ab5-3d186a4471b4" width="150" height="25"/><br/>

#### [질의 2-2] 신간도서 안내를 위해 (이름, 주소, 핸드폰)의 카탈로그 주소록을 만드시오.
-
<img src="https://github.com/silxbro/cs-study/assets/142463332/20b02ec6-e9f8-4611-932a-e712525d4c3a" width="170" height="20"/><br/>

- 고객 릴레이션에서 카탈로그 방송 주소록을 만드려면 고객번호와 주민번호는 필요하지 않고 이름, 주소, 핸드폰 번호만 알면 된다.
  이와 같이 프로젝션은 원하는 속성 값만 추출하고자 할 때 사용한다. 결과 릴레이션은 세 개의 속성을 가지므로 차수가 3이고, 카디날리티는 고객 릴레이션과 동일한 4이다.

- 프로젝션의 예

  <img src="https://github.com/silxbro/cs-study/assets/142463332/94238e20-e8e2-4a2c-a156-490a7644ebde" width="430" height="350"/><br/>
  <br/>

## 3. 집합 연산
관계대수에서 집합 연산은 수학의 집합 연산과 같은 연산으로, 합집합(union) ⋃, 교집합(intersection) ⋂, 차집합(set difference) –, 카티전 프로덕트(cartesian product) ⨉
등이 있다. 합집합, 차집합, 카티전 프로덕트는 기본 연산자이고, 교집합은 기본 연산자로 정의가 가능한 유도된 연산자이다(R⋂S = R–(R–S)).

집합 연산자는 두 개의 릴레이션을 대상으로 하는 이항 연산자다. 카티전 프로덕트를 제외한 합집합, 교집합, 차집합은 두 릴레이션의 차수 및 도메인과 속성의 순서가 동일해야 한다.
즉 각 릴레이션의 속성 수가 같고 순서도 같아야 하며 각각 동일한 도메인으로 대응되어야 한다. 이 조건을 **합병가능**(union compatible)이라고 한다.
관계대수의 집합 연산(⋃, ⋂, –)은 합병가능해야 성립된다. 이때 속성 이름은 동일하지 않아도 되며, 반환되는 릴레이션의 속성 이름은 첫 번째 릴레이션의 이름과 같다.

### 합집합
합집합은 수학의 합집합과 동일한 개념으로 두 개의 릴레이션을 합하여 하나의 릴레이션을 반환한다. 기호 역시 같은 `⋃`를 사용한다.
두 개의 릴레이션은 서로 같은 속성 순서와 도메인을 가져야 한다. 반환되는 결과는 첫 번째 릴레이션의 속성 이름을 가진다. 작성 형식은 다음과 같다. R과 S는 릴레이션을 나타낸다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/f402643c-6091-4e2f-a94e-84be205715d9" width="70" height="20"/><br/>

#### [질의 2-3] 마당서점은 지점A와 지점B가 있다. 두 지점의 도서는 각 지점에서 관리하며 릴레이션 이름은 각각 도서A, 도서B이다. 마당서점의 전체 도서를 하나의 릴레이션으로 보이시오.
- 도서A ⋃ 도서B
- 릴레이션 도서A와 도서B는 서로 동일한 속성과 동일한 도메인을 가지므로 합병가능하다.
  이때 주의할 점은 도서A의 카디날리티가 3, 도서B의 카디날리티 역시 3이지만 결과 릴레이션의 카디날리티는 5가 된다는 점이다.
  이는 도서A의 1번 도서와 도서B의 1번 도서가 동일하여 결과 릴레이션에 한 번만 표시되었기 때문이다.

- 합집합의 예

  <img src="https://github.com/silxbro/cs-study/assets/142463332/5e6e9c35-baaf-40e4-b324-62d7bc61b2ec" width="360" height="450"/><br/>

### 교집합
교집합 역시 합병가능한 두 릴레이션을 대상으로 하며, 두 릴레이션이 공통으로 가지고 있는 튜플을 반환한다. 기호는 `⋂`를 사용한다. 작성 형식은 다음과 같다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/a0d3612b-9f72-4a91-8e8c-65b784e7cfb9" width="70" height="20"/><br/>

#### [질의 2-4] 마당서점의 두 지점에서 동일하게 보유하고 있는 도서 목록을 보이시오.
- 도서A ⋂ 도서B
- 릴레이션 도서A와 도서B의 차수가 각각 4이며, 도메인 역시 동일하여 합병가능함을 알 수 있다.
  교집합은 두 릴레이션에 있는 동일한 튜플을 반환하므로 결과 릴레이션에서는 1번 도서 '축구의 역사'만 보여준다.

- 교집합의 예

  <img src="https://github.com/silxbro/cs-study/assets/142463332/fa240f29-04d6-4f17-8164-35280710b429" width="360" height="350"/><br/>

### 차집합
차집합은 첫 번째 릴레이션에는 속하고 두 번째 릴레이션에는 속하지 않는 튜플을 반환한다. 기호는 `–`를 사용하며 다른 집합 연산과 동일하게 합병가능해야 한다.
작성 형식은 다음과 같다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/fbea6216-d46e-4276-b360-1c133a38178a" width="70" height="20"/><br/>

#### [질의 2-5] 마당서점의 두 지점 중 지점A에서만 보유하고 있는 도서 목록을 보이시오.
- 도서A – 도서B
- 릴레이션 도서A와 도서B의 차수와 도메인이 동일하여 합병가능함을 알 수 있다.
  차집합은 첫 번째 릴레이션(도서A)을 기준으로 수행되는데, 도서A의 1, 2, 3번 도서와 도서B의 1, 4, 5번 도서 중 도서A에만 있는 2, 3번 도서를 결과로 반환한다.

- 차집합의 예

  <img src="https://github.com/silxbro/cs-study/assets/142463332/f227912a-8cb4-4f18-9e6e-a1118debe837" width="360" height="350"/><br/>

### 카티전 프로덕트
지금까지의 집합 연산이 두 릴레이션의 수직적 연산이었다면 카티전 프로덕트(cartesian product)는 **수평적** 연산이다.
카티전 프로덕트는 두 릴레이션을 연결시켜 하나로 합칠 때 사용한다. 결과 릴레이션은 첫 번째 릴레이션의 오른쪽에 두 번째 릴레이션의 모든 튜플을 순서대로 배열하여 반환한다.
기호는 `⨉`를 사용하며 속성과 도메인이 동일할 필요는 없다. 결과 릴레이션의 차수는 두 릴레이션의 차수의 합이며, 카디날리티는 두 릴레이션의 카디날리티의 곱이다.
- 예를 들어 첫 번째 릴레이션의 차수가 4, 카디날리티가 3이고 두 번째 릴레이션의 차수가 5, 카디날리티가 4라면 결과 릴레이션의 차수는 9(4+5), 카디날리티는 12(3⨉4)가 된다.
  최종적으로 결과 릴레이션은 아홉 개의 속성과 열두 개의 튜플을 가진다.

결과 릴레이션의 속성 이름은 두 릴레이션에서 그대로 가져와 사용한다. 그런데 만약 두 릴레이션이 동일한 속성 이름을 가지고 있을 경우 충돌할 수도 있다.
이때는 결과 릴레이션의 속성 이름을 `<릴레이션 이름>.<속성 이름>`의 형태로 표현하거나 순서(위치)를 사용하여 표현한다. 카티전 프로덕트 연산의 작성 형식은 다음과 같다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/eeaca292-12e0-4f54-805a-e23eefef6613" width="70" height="20"/><br/>

#### [질의 2-6] 고객 릴레이션과 주문 릴레이션의 카티전 프로덕트를 구하시오.
- 고객 ⨉ 주문

- 카티전 프로덕트의 예

  <img src="https://github.com/silxbro/cs-study/assets/142463332/9a2681d0-6361-4bba-82ce-cf964fd2526d" width="650" height="450"/><br/>
  - 열두 개의 튜플 중 의미 있는 튜플은 고객번호의 속성 값이 일치하는 네 개의 튜플 뿐이다(2, 4, 5, 7번째 튜플).

카티전 프로덕트는 두 릴레이션을 무조건 수평으로 합친 결과를 반환하기 때문에 결과에 의미가 없으며, 대부분 유용한 자료로 활용하기 힘들다.
이때 셀렉션과 프로젝션 연산을 조합하여 두 릴레이션의 관계에 따른 의미 있는 결과를 찾으면 유용하게 사용할 수 있다.
<br/>
<br/>
## 4. 조인
조인(join)은 두 릴레이션의 공통 속성을 기준으로 속성 값이 같은 튜플을 수평으로 결합하는 연산이다.
즉 두 릴레이션을 카티전 프로덕트 연산을 한 후 셀렉션 연산을 한 것으로 정의할 수 있다. 이때 셀릭션 연산의 <조건>은 속성 값이 같은지 비교하는 식이다.

조인 연산의 기호는 `⨝`를 사용한다. 조인 연산자(⨝)는 기본 연산자의 조합으로 구현 가능한 유도된 연산자로, 두 개의 릴레이션을 대상으로 하는 이항 연산자이다.
조인 연산의 작성 형식은 다음과 같다. R과 S는 릴레이션이며 c는 <조인조건>을 나타낸다. 다음 식은 기본 연산자로 조인 연산을 표현한 것이다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/d6f8b5dc-cbdc-48be-b4af-aae49cb0ac1b" width="180" height="22"/><br/>

조인을 수행하기 위해서는 두 릴레이션의 조인에 참여하는 속성이 서로 동일한 도메인으로 구성되어야 한다. 조인 연산의 결과는 공통 속성의 속성 값이 동일한 튜플만을 반환한다.

조인 연산은 크게 기본 조인 연산과 확장된 조인 연산으로 구분할 수 있다.
기본 조인 연산에는 두 릴레이션 간의 속성 값을 비교(=, ≠, ≤, ≥, <, >)하여 조건에 맞는 튜플을 반환하는 **세타조인**(<img src="https://github.com/silxbro/cs-study/assets/142463332/2f222eb1-4a47-4dd5-a63a-b6189fa24af8" width="20" height="10"/>),
속성 값이 같은 튜플만을 반환하는 **동등조인**(⨝), 속성 이름이 같은 튜플만을 대상으로 하되 중복 속성을 제거하고 반환하는 **자연조인**(<img src="https://github.com/silxbro/cs-study/assets/142463332/81c0ebaa-7fce-430c-a076-56526f7aa00f" width="20" height="10"/>)이 있다.
확장된 조인 연산에는 두 릴레이션을 조인한 후 한 릴레이션의 튜플만 반환하는 **세미조인**(⋉,⋊), 조인에 실패한 값들을 NULL 값으로 채워서 반환하는 **외부조인**(⟕,⟖,⟗)이 있다.

### 세타조인과 동등조인
세타조인(theta join) 𝜃은 조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플만 반환한다. 세타조인의 조건은 {=, ≠, ≤, ≥, <, >} 중 하나가 된다.
작성 형식은 다음과 같다. R과 S는 릴레이션이며 r은 R의 속성, s는 S의 속성을 나타낸다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/4a27c1d2-5e1b-4aeb-8cf1-0969d2c88626" width="115" height="22"/><br/>

동등조인(equi join)은 세타조인에서 = 연산자를 사용한 조인을 말한다. 보통 조인 연산이라고 하면 동등조인을 지칭한다. 사용하는 기호는 `⨝`이다. 작성 형식은 다음과 같다.
- 동등조인은 내부조인(inner join)이라고도 한다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/3e043751-23d3-4126-8229-b523136fe66e" width="100" height="22"/><br/>

#### [질의 2-7] 고객과 고객의 주문 사항을 모두 보이시오.
-
<img src="https://github.com/silxbro/cs-study/assets/142463332/29a74f40-2745-448a-8908-2dff504ab7b9" width="230" height="18"/><br/>

- 동등조인의 결과 릴레이션의 차수는 첫 번째 릴레이션과 두 번째 릴레이션의 차수를 합한 것과 같으며, 속성 이름은 두 릴레이션의 속성 이름을 그대로 사용한 것을 알 수 있다.
  두 릴레이션의 속성 이름이 같은 경우 첫 번째 릴레이션의 속성부터 시작하여 순서대로 나타낸다.

- 동등조인의 예

  <img src="https://github.com/silxbro/cs-study/assets/142463332/d08b40a5-3334-48fd-9b01-aa7f1e550321" width="650" height="450"/><br/>

### 자연조인
자연조인(natural join)은 동등조인에서 조인에 참여한 속성이 두 번 나오지 않도록 두 번째 속성을 제거한 결과를 반환한다.
기호는 '<img src="https://github.com/silxbro/cs-study/assets/142463332/81c0ebaa-7fce-430c-a076-56526f7aa00f" width="20" height="10"/>'을 사용하며
자연조인의 결과 차수는 '두 릴레이션의 차수의 합 - 1'이다. 자연조인의 작성 형식은 다음과 같다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/bda8abf0-0a4b-40e5-971f-7003c673143e" width="130" height="20"/><br/>

#### [질의 2-8] 고객과 고객의 주문 사항을 모두 보여주되 같은 속성은 한 번만 표시하시오.
- <img src="https://github.com/silxbro/cs-study/assets/142463332/c6538f34-24c8-4732-8855-48a3706fb539" width="270" height="17"/><br/>

- 자연조인의 예

  <img src="https://github.com/silxbro/cs-study/assets/142463332/3ba18337-6c4e-42da-a1c8-2c9865e537eb" width="650" height="450"/><br/>

### 외부조인과 세미조인
기본 조인 연산은 두 릴레이션의 관계를 표현하는 속성 간의 조건에 따라 결과 릴레이션을 반환한다.
관계 데이터 모델에서 조인 연산의 사용이 늘어남에 따라 최초에 정의한 조인에서 더 확장된 개념인 외부조인과 세미조인이 나타나게 되었다.

외부조인(outer join)은 자연조인의 확장된 형태이다. 외부조인은 자연조인 시 조인에 실패한 튜플을 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.
외부조인은 모든 속성을 보여주는 기준 릴레이션의 위치에 따라 왼쪽(left) 외부조인, 오른쪽(right) 외부조인, 완전(full) 외부조인으로 나뉜다.
기호는 각각 '⟕', '⟖', '⟗'를 사용한다.

- 왼쪽 외부조인의 예

  <img src="https://github.com/silxbro/cs-study/assets/142463332/446d6927-16e8-478f-8650-4ff3afe9eca1" width="230" height="300"/><br/>
  - 릴레이션 R1은 속성 A와 B를 가지며 릴레이션 R2는 속성 B와 C를 가지고 있다. 두 릴레이션을 속성 B를 기준으로 자연조인을 하면 (aa, 1, dd)와 (cc, 3, ee)가 생성된다.
    왼쪽 외부조인은 조인에 참여하지 못한 R1의 (cc, 2) 튜플을 결과에 포함시키면 된다. 이때 결과의 C 속성은 해당되는 값이 없으므로 NULL 값을 넣어서 반환한다.

외부조인의 작성 형식은 다음과 같다.
- 왼쪽 외부조인 :&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/6931e6e6-2c4c-4887-ad0c-fc3d8890a3ee" width="90" height="15"/>
- 완전 외부조인 :&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/9d8a1810-564b-46ed-8f38-b4dfac1e57ca" width="95" height="15"/>
- 오른쪽 외부조인 :&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/63b46b6a-67b4-48b5-9134-bfee8f5d86e2" width="90" height="15"/>

#### [질의 2-9] 마당서점의 고객과 고객의 주문 내역을 보이시오.
1. 고객 기준으로 주문내역이 없는 고객도 모두 보이시오.
- <img src="https://github.com/silxbro/cs-study/assets/142463332/ffe8fb8b-1f4d-44f3-953e-168d1c9a66e9" width="250" height="15"/><br/>

2. 주문내역이 없는 고객과 고객 릴레이션에 고객번호가 없는 주문을 모두 보이시오.
- <img src="https://github.com/silxbro/cs-study/assets/142463332/8e24bfe0-c1c6-43e0-9b3d-0ce96665eb5b" width="250" height="16"/><br/>

3. 주문내역 기준으로 고객 릴레이션에 고객번호가 없는 주문도 모두 보이시오.
- <img src="https://github.com/silxbro/cs-study/assets/142463332/1d423b05-4190-4d85-9b1c-531bb13d8131" width="250" height="16"/><br/>

- 외부조인의 예

  <img src="https://github.com/silxbro/cs-study/assets/142463332/97646374-8c20-425d-8ed7-761e7f17dbfd" width="750" height="500"/><br/>


세미조인(semi join)은 자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환한다. 기호는 '⋉', '⋊'를 사용하며 작성 형식은 다음과 같다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/2d7f5225-1aa6-44dc-a0a6-961b75ef8486" width="90" height="17"/>

세미조인은 기호에서 닫힌 쪽 릴레이션의 튜플만 반환한다.

#### [질의 2-10] 마당서점의 고객 중 주문 내역이 있는 고객의 고객 정보를 보이시오.
- <img src="https://github.com/silxbro/cs-study/assets/142463332/836338a3-bfcc-40b6-a4cf-43e7ccae6cf5" width="250" height="17"/><br/>

- 세미조인의 결과를 보면 세 개의 튜플만 남은 것을 볼 수 있다.
  최초에는 주문 릴레이션의 영향을 받아 여섯 개의 튜플을 가진 릴레이션이 생성되지만, 닫힌 쪽 릴레이션(고객 릴레이션)만 반환되므로 동일한 튜플은 제거되고 3개만 남는다.

- 세미조인(왼쪽이 닫힌 경우)의 예

  <img src="https://github.com/silxbro/cs-study/assets/142463332/f81fdccc-2f52-4181-82fb-b61dba729c91" width="600" height="350"/><br/>
  <br/>

## 5. 디비전
디비전(division)은 다른 연산과 달리 릴레이션의 속성 값의 집합으로 연산을 수행한다.
릴레이션 R의 속성은 (A1, A2, ..., An, B1, B2, ..., Bm)으로 표시할 수 있고 릴레이션 R의 차수는 n+m이 된다.
또 릴레이션 R의 속성인 B의 부분집합으로 이루어진 릴레이션 S가 있을 경우 릴레이션 S의 속성은 (B1, B2, ..., Bm)이 되며 차수는 m이 된다.
이때 릴레이션 R ÷ S를 하면, 릴레이션 S의 속성 B 값과 릴레이션 R의 속성 B 값이 서로 동일하게 대응하는 릴레이션 R의 속성 A의 튜플을 반환한다.
디비전 연산은 특정 값들을 모두 갖고 있는 튜플을 찾을 때 사용한다. 그러나 실제로 자주 사용되지 않으며 조인 연산의 조합으로 같은 디비전 연산을 수행할 수 있다.
디비전 연산의 작성 형식은 다음과 같다.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/0a344a35-f87e-4a4d-930e-69ddc6f71628" width="70" height="17"/>

- 디비전 연산의 예

  <img src="https://github.com/silxbro/cs-study/assets/142463332/adca8677-137e-455a-8238-d7c5894573d5" width="400" height="350"/><br/>
  - R ÷ S1에서 릴레이션 S1의 튜플이 {b1}일 때, 릴레이션 R에서 B 속성에 b1 튜플이 존재하는 속성 A={s1, s2, s3, s4}를 반환한다.
  - R ÷ S2에서 S2의 튜플이 {b1, b3}이면, 릴레이션 R에서 B 속성에 {b1, b3}가 모두 존재하는 A={s1}을 반환한다.
  - R ÷ S3에서 S3의 튜플이 {b1, b2, b4}이면, 릴레이션 R에서 B 속성에 {b1, b2, b4}가 모두 존재하는 A={s1, s2, s4}를 반환한다.
    <br/>

## 6. 관계대수 예제
관계대수식은 실제로 하나의 연산자만 단독으로 사용하는 경우는 드물고, 여러 연산자들을 복합하여 사용하는 경우가 많다.
- 예를 들어 카티전 프로덕트의 경우 단독으로 사용하면 의미 없는 결과를 반환하므로, 의미 있는 결과를 반환하기 위해 프로젝트와 셀렉션 연산을 조합해서 많이 사용한다.

여러 연산자를 조합하는 관계대수식의 경우 연산 순서는 수학의 연산과 마찬가지로 괄호() 먼저 처리한다.
이때 각 단계의 연산 결과는 다음 단계의 삽입값이 되어 순차적으로 왼쪽에서 오른쪽으로 처리된다.

###  셀렉션, 프로젝션, 집합 연산의 복합 사용
#### [질의 2-11] 마당서점의 도서 중 가격이 8,000원 이하인 도서이름과 출판사를 보이시오.
#### 🔳 마당서점의 지점이 하나인 경우
마당서점의 지점이 하나일 경우 대수식은 단일 릴레이션을 대상으로 한다. 대수식은 먼저 가격이 8,000원 이하인 도서를 추출하기 위해 셀렉션 연산을 한다.
다음으로 프로젝션 연산을 통해 도서이름과 출판사 속성만 추출한다.
- <img src="https://github.com/silxbro/cs-study/assets/142463332/07bc33bf-fefa-4922-9d65-742c5eb810e4" width="240" height="17"/><br/>

- 단일 릴레이션에서 셀렉션, 프로젝션 연산의 복합 사용

  <img src="https://github.com/silxbro/cs-study/assets/142463332/02b600f6-1771-46cd-bcca-a75ef894c6ab" width="600" height="270"/><br/>

#### 🔳 마당서점의 지점이 둘 이상인 경우
마당서점에 두 개의 지점이 있고 각 지점마다 도서 릴레이션이 따로 존재하는 경우 대수식은 두 릴레이션을 대상으로 한다.
대수식은 먼저 지점A의 도서 릴레이션과 지점B의 도서 릴레이션에서 각각 셀렉션 연산으로 조건(가격<=8000)을 만족하는 튜플을 추출한다.
다음으로 합집합 연산을 이용해 두 릴레이션을 합친다.
결과 릴레이션의 카디날리티가 2가 되는 것은 도서번호 1이 두 릴레이션에 중복되어 있어 릴레이션의 정의에 따라 하나만 표현했기 때문이다.
마지막으로 프로젝션 연산을 통해 도서이름과 출판사 속성만 추출한다.
- <img src="https://github.com/silxbro/cs-study/assets/142463332/d1ff421c-7a3a-41d2-946b-4edbd3533533" width="370" height="17"/><br/>

- 두 개 이상의 릴레이션에서 셀렉션, 프로젝션, 합집합 연산의 복합 사용

  <img src="https://github.com/silxbro/cs-study/assets/142463332/8d4b2980-473f-4b97-a1e3-bf3b278747ef" width="700" height="430"/><br/>

### 카티전 프로덕트를 사용한 연산과 조인을 사용한 연산
여기서 같은 결과를 가져오는 두 대수식에 대해 살펴보는 것은 대수식 사용에 대한 이해와 함께 여러 대수식을 고민해보고 최적의 결과를 가져오는 대수식을 찾는 방법을
알아보기 위함이다.
- 카티전 프로덕트 연산과 같이 연산 결과의 크기가 커지면 DBMS에서 처리할 때 응답 시간이 길어진다.

#### [질의 2-12] 마당서점의 박지성 고객의 거래 내역 중 주문번호, 이름, 가격을 보이시오.
#### 🔳 카티전 프로덕트를 사용한 연산
대수식은 먼저 괄호() 안의 '고객⨉주문' 연산으로 카티전 프로덕트 연산을 한 후, 그 결과 릴레이션에 셀렉션 연산<br/>'<img src="https://github.com/silxbro/cs-study/assets/142463332/3b0715bb-cd62-4e64-a17c-89ca5b87c05e" width="330" height="17"/>'을 하고,
마지막으로 프로젝션 연산<br/>'<img src="https://github.com/silxbro/cs-study/assets/142463332/c050c966-8cb0-4357-acb6-d6e720b10857" width="250" height="17"/>'을 수행하여 원하는 속성만 가진 릴레이션을 반환한다.

- <img src="https://github.com/silxbro/cs-study/assets/142463332/ef1b7437-f800-4ce3-b162-65b52334de75" width="670" height="22"/><br/>

#### 🔳 조인을 사용한 연산
같은 질의를 조인을 사용하여 표현하면 간결한 식이 된다.

- <img src="https://github.com/silxbro/cs-study/assets/142463332/c1335d0e-096b-4ddb-bfc4-bee027105310" width="550" height="19"/><br/>

관계대수식은 연산자의 조합에 따라 절차는 다르지만 같은 결과를 낼 수 있다.
DBMS 역시 사용자의 질의에 따라 내부에서 **질의 최적화**(Query Optimization) 과정을 거쳐 같은 결과를 내는 여러 대수식을 생성하고 그 중 가장 효율적인 대수식을 선택하여 처리한다.
- 대부분의 DBMS에서 질의 최적화는 DBMS 내의 옵티마이저를 통해 수행한다. 옵티마이저란 SQL을 수행하기 위한 최적의 경로를 찾는 DBMS의 내부 엔진이다.