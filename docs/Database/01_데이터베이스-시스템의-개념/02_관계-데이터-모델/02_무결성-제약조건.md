# 무결성 제약조건
<br/>

데이터베이스에 저장된 데이터는 결함이 없어야 하며 질의에 대해 신뢰성 있는 답을 제공해야 한다.
- 예를 들어 사람의 나이를 조회했는데 200이 나오거나, 대학에서 수강인원이 40명인 과목에 41명이 수강신청이 되는 경우 등은 모두 무결성 제약조건을 위배한 것이다.

데이터를 저장하는 데 있어서 데이터베이스는 일관성을 유지하고 중복을 제거하는 등 데이터의 신뢰도를 유지해야 한다.
따라서 데이터의 삽입, 삭제, 수정 시 여러 가지 제약조건이 따른다.
이 절에서는 관계 데이터베이스에서 데이터의 사용 및 관계 표현에 가장 중요한 개념인 키(key)를 먼저 공부한 다음 제약조건에 대해 살펴본다.
<br/>
<br/>
## 1. 키
관계 데이터베이스에서 **키**(key)는 릴레이션에서 **특정 튜플을 식별할 때 사용하는 속성 혹은 속성의 집합**이다.
릴레이션은 중복된 튜플을 허용하지 않기 때문에 각각의 튜플에 포함된 속성들 중 어느 하나(혹은 하나 이상)는 값이 달라야 한다.
즉 키가 되는 속성(혹은 속성의 집합) 반드시 값이 달라서 튜플들을 서로 구별할 수 있어야 한다.

키는 릴레이션 간의 관계를 맺는 데도 사용된다. 키는 각 릴레이션의 튜플을 유일하게 식별하는 장치이며 동시에 각 릴레이션 간의 관계를 말해주는 연결고리이다.
- 예를 들어 도서 릴레이션의 도서번호는 도서 릴레이션의 키이면서 주문 릴레이션에 저장되어 어떤 도서를 주문했는지 알 수 있도록 관계를 맺어주고 있다.
  고객 릴레이션과 주문 릴레이션의 고객번호 역시 같은 역할을 한다.

다음 그림은 마당서점 데이터의 일부를 보여준다. 이 테이블들을 중심으로 키의 개념과 제약조건에 대해 알아보자.

#### [마당서점 데이터베이스]
#### 고객
|고객번호|이름|주민번호|주소|핸드폰|
|:---|:---|:---|:---|:---|
|1|박지성|810101-1111111|영국 맨체스타|000-5000-0001|
|2|김연아|910101-2222222|대한민국 서울|000-6000-0001|
|3|장미란|830101-2333333|대한민국 강원도|000-7000-0001|
|4|추신수|820101-1444444|미국 클리블랜드|000-8000-0001|
#### 도서
|도서번호|도서이름|출판사|가격|
|:---|:---|:---|:---|
|1|축구의 역사|굿스포츠|7000|
|2|축구아는 여자|나무수|13000|
|3|축구의 이해|대한미디어|22000|
|4|골프 바이블|대한미디어|35000|
|5|피겨 교본|굿스포츠|8000|
#### 주문
|고객번호|도서번호|판매가격|주문일자|
|:---|:---|:---|:---|
|1|1|7000|2014-07-01|
|1|2|13000|2014-07-03|
|2|5|8000|2014-07-03|
|3|2|13000|2014-07-04|
|4|4|35000|2014-07-05|
|1|3|22000|2014-07-07|
|4|3|22000|2014-07-07|

### 슈퍼키
슈퍼키(super key)는 **튜플을 유일하게 식별할 수 있는 하나의 속성 혹은 속성의 집합**을 말한다.
- 고객 릴레이션에서 속성별로 튜플 식별이 가능한지 살펴보자.
  - 고객번호 : 고객별로 유일한 값이 부여되어 있기 때문에 튜플을 식별할 수 있다.
  - 주민번호 : 개인별로 유일한 값이 부여되어 있기 때문에 튜플을 식별할 수 있다.
  - 이름 : 동명이인이 있을 경우 튜플을 유일하게 식별할 수 없다.
  - 주소 : 가족끼리는 같은 정보를 사용하므로 튜플을 식별할 수 없다.
  - 핸드폰 : 한 사람이 여러 개의 핸드폰을 사용할 수 있고 반대로 핸드폰을 사용하지 않는 사람이 있을 수 있기 때문에 튜플을 식별할 수 없다.
    - 핸드폰 번호가 없을 경우 데이터베이스에서는 값이 없다는 의미로 NULL 값을 사용한다.

튜플을 유일하게 식별할 수 있는 값이면 모두 슈퍼키가 될 수 있다. 고객 릴레이션의 경우 고객번호와 주민번호를 포함한 모든 속성의 집합이 슈퍼키가 된다.
정의에 따라 고객 릴레이션의 슈퍼키를 나열하면 다음과 같다. 슈퍼키는 포함하지 않아도 되는 속성을 포함할 수 있다.
```
  (주민번호), (주민번호, 이름), (주민번호, 이름, 주소), (주민번호, 이름, 핸드폰),
  (고객번호), (고객번호, 이름, 주소), (고객번호, 이름, 주민번호, 주소, 핸드폰), ...
```
하지만 우리가 관심을 두어야 할 것은 튜플을 식별할 수 있는 최소한의 속성 집합이다.
키를 구성하는 속성이 많으면 그만큼 관계 표현이 복잡해지고 사용에도 불편이 따르기 때문이다.

### 후보키
후보키(candidate key)는 **튜플을 유일하게 식별할 수 있는 속성의 최소 집합**이다.
이는 효율성 측면에서 매우 중요하다(이후 특별한 언급 없이 키라고 지칭하는 것은 후보키를 말한다).
- 고객 릴레이션의 경우 슈퍼키는 많지만 후보키는 '주민번호', '고객번호'만 될 수 있다. 예를 들어 (주민번호, 이름)은 슈퍼키이지만 후보키는 아니다.
  없어도 되는 속성인 '이름'이 포함되어 있기 때문이다.
- 주문 릴레이션은 고객이 도서를 구입했을 때 생성되는데, 한 명의 고객이 여러 권의 도서를 구입할 수 있고 여러 명의 고객이 한 권의 도서를 구입할 수도 있다.
  단, 한 명의 고객이 같은 도서를 다시 구입할 수 없다고 가정한다. 주문 릴레이션의 후보키로 어떤 것이 가능한지 살펴보자.
  - 고객번호 : 한 명의 고객이 여러 권의 도서를 구입할 수 있으므로 후보키가 될 수 없다.
  - 도서번호 : 여러 번의 주문 기록이 있을 수 있으므로 튜플을 유일하게 식별할 수 없다.

  하지만 고객번호와 도시번호 두 속성을 키 값으로 하면 어떨까?
  - (고객번호, 도서번호) : (고객번호, 도서번호)가 동일한 주문 기록이 없으므로 모든 튜플을 유일하게 식별할 수 있다.

  주문 릴레이션의 후보는 두 개의 속성을 합한 (고객번호, 도서번호)가 된다. 참고로 이렇게 두 개 이상의 속성으로 이루어진 키를 복합키(composite key)라고 한다.
  만약 한 명의 고객이 동일한 도서를 구입할 수 있다고 가정하면 (고객번호, 도서번호)는 튜플을 유일하게 식별할 수 없게 되어 후보키가 되지 못한다. 이 문제는 아래에서 다시 언급한다.

### 기본키
기본키(PK, primary key)는 **여러 후보키 중 하나를 선정하여 대표로 삼는 키**를 말한다.
후보키가 하나뿐이라면 그 후보키를 기본키로 사용하면 되고 여러 개라면 릴레이션의 특성을 반영하여 하나를 선택하면 된다.

기본키는 릴레이션을 대표하므로 선택하기 전에 여러 사항을 고려해야 한다.
- 예를 들어 고객 릴레이션의 경우 기본키로 '주민번호'와 '고객번호'를 선택할 수 있다. 먼저 주민번호를 살펴보면 개인에게 하나씩 주어지며 변경이 불가능하다.
  변경이 불가능하다는 것은 튜플 식별 시 자료의 변형에 잘 대처할 수 있는 여지를 제공한다.
  그러나 나이, 생년월일, 성별, 출생지 등에 관한 개인정보가 포함되어 있어 개인정보 보호에는 취약하다.
  최근 개인정보 보호에 대한 관심이 높아지면서 주민번호의 사용은 최대한 자제하고 있기 때문에 주민번호 같은 중요한 정보를 기본키로 사용하는 것은 부담이 된다.
  따라서 기본키로 고객번호를 선택하는 것이 좋다.

지금까지의 내용을 토대로 기본키 선정 시 고려사항을 정리하면 다음과 같다.
다음 고려사항 중 일부는 기본키 제약조건이라고 하며 기본키 제약조건에 대해서는 다음 절에서 자세히 설명한다.
- 릴레이션 내 튜플을 식별할 수 있는 고유한 값을 가져야 한다.
- NULL 값은 허용하지 않는다.
  - NULL은 '없다(無)', '존재하지 않는다'라는 의미로(missing information and inapplicable information), 데이터 값이 입력되지 않은 경우 DBMS는 NULL이라는 특수한 값을 저장한다.
    이 값은 공백(' '). 0 등과는 다르다.
- 키 값의 변동이 일어나지 않아야 한다.
- 최대한 적은 수의 속성을 가진 것이어야 한다.
- 향후 키를 사용하는 데 있어서 문제 발생 소지가 없어야 한다.

릴레이션 스키마를 표현할 때 기본키는 아래와 같이 밑줄을 그어 표시한다.

> 릴레이션 이름(<u>속성 1</u>, 속성 2, ..., 속성 N)
- 고객(<u>고객번호</u>, 이름, 주민번호, 주소, 핸드폰)
- 도서(<u>도서번호</u>, 도서이름, 출판사, 가격)

### 대리키
기본키가 보안을 요하거나, 여러 개의 속성으로 구성되어 복잡하거나, 마땅한 기본키가 없을 때는 **일련번호 같은 가상의 속성을 만들어 기본키로 삼는 경우**가 있다.
이러한 키를 대리키(surrogate key) 혹은 인조키(artificial key)라고 한다.
대리키는 DBMS나 관련 소프트웨어에서 임의로 생성하는 값으로 사용자가 직관적으로 그 값의 의미를 알 수 없다.
- 대리키(surrogate key)는 영어권에서 의미가 잘 전달되지 않아 인조키(artificial key)라고도 한다.
- 주문 릴레이션은 (고객번호, 도서번호)의 복합키를 사용하여 튜플을 식별한다. 그러나 매번 기본키로 (고객번호, 도서번호)를 사용하면 복잡하고 불편하다.
  이 경우 다음 그림과 같이 사용자에게 의미는 없지만 '주문번호'라는 새로운 속성을 만들면 불편함을 해소할 수 있다.
  이와 더불어 주문번호 속성을 이용하면 한 명의 고객이 같은 도서를 구입할 수 있어 주문 테이블의 기능이 향상된다.
  #### [대리키를 사용하도록 변경된 주문 릴레이션]
  |주문번호|고객번호|도서번호|판매가격|주문일자|
    |:---|:---|:---|:---|:---|
  |1|1|1|7000|2014-07-01|
  |2|1|2|13000|2014-07-03|
  |3|2|5|8000|2014-07-03|
  |4|3|2|13000|2014-07-04|
  |5|4|4|35000|2014-07-05|
  |6|1|3|22000|2014-07-07|
  |7|4|3|22000|2014-07-07|

### 대체키
대체키(alternate key)는 **기본키로 선정되지 않은 후보키**를 말한다.
- 고객 릴레이션의 경우 고객번호와 주민번호 중 고객번호를 기본키로 정하면 '주민번호'가 대체키가 된다.

### 외래키
외래키(FK, foreign key)는 **다른 릴레이션의 기본키를 참조하는 속성**을 말한다.
지금까지 살펴본 키들이 단일 릴레이션을 기준으로 설명하였다면 외래키는 다른 릴레이션의 기본키를 참조하여 관계 데이터 모델의 특징인 릴레이션 간의 관계(relationship)를 표현한다.

다음 그림에서 주문 릴레이션의 기본키인 주문번호는 고객이 도서를 주문하면 생성된다. 이때 해당되는 고객번호와 도서번호도 주문 릴레이션에 저장된다.
주문 릴레이션에서 주문번호를 알면 어떤 고객이 어떤 도서를 구입했는지 알 수 있다.
여기서 '어떤 고객'과 '어떤 도서'를 표시하기 위해 사용된 고객번호와 도서번호는 각각 고객 릴레이션과 도서 릴레이션의 기본키이며, 이 키들은 주문 릴레이션에서 외래키로 사용되었다.
릴레이션 간의 참조 관계는 다음과 같다.

#### [릴레이션 간의 참조 관계]
<img src="https://github.com/silxbro/cs-study/assets/142463332/f6063c6c-5ab7-4315-a47a-468760a31ffb" width="700" height="400"/><br/>

외래키가 성립하기 위해서는 참조하고(refer) 참조되는(referred) 양쪽 릴레이션의 **도메인이 서로 같아야 한다**.
또한 참조되는 릴레이션의 기본키 값이 변경되면 이 기본키를 참조하는 외래키 값 역시 변경되어야 한다.
참조하는 외래키 값이 참조되는 **기본키 값에 연동된다**는 의미로, 외래키는 항상 데이터의 일관성을 유지해야 한다.
이러한 특징을 `외래키 제약조건`이라고 하며 자세한 내용은 다음 절에서 다시 언급한다.

외래키(참조하는 키)는 참조되는 릴레이션의 기본키와 달리 NULL 값을 포함할 수 있고 중복값도 허용한다.
- 주문 릴레이션을 보면 고객번호 1이 세 번 중복된 것을 확인할 수 있다.

외래키 사용시 참조하는 릴레이션과 참조되는 릴레이션이 꼭 다른 릴레이션일 필요는 없다. 즉 자기 자신의 기본키를 참조할 수도 있다.
- 멘토 릴레이션의 각 선수는 멘토가 있으며, 멘토는 멘토번호 속성에 있는 선수번호를 통해 알 수 있다.
  김연아의 멘토는 장미란(선수번호 3)이고, 장미란의 멘토는 추신수(선수번호 4)이다. 그리고 박지성과 추신수는 멘토가 없어 "값이 없음"의 의미로 NULL 값이 저장되어 있다.

  #### [멘토 릴레이션]
  &nbsp;&nbsp;&nbsp;<img src="https://github.com/silxbro/cs-study/assets/142463332/5af1ad78-772e-4ffb-b484-9a37ae3d6065" width="320" height="180"/><br/>

외래키의 특징을 정리하면 다음과 같다.
- 관계 데이터 모델의 릴레이션 간의 관계를 표현한다.
- 다른 릴레이션의 기본키를 참조하는 속성이다.
- 참조하고(외래키) 참조되는(기본키) 양쪽 릴레이션의 도메인은 서로 같아야 한다.
- 참조되는(기본키) 값이 변경되면 참조하는(외래키) 값도 변경된다.
- NULL 값과 중복 값 등이 허용된다.
- 자기 자신의 기본키를 참조하는 외래키도 가능하다.
- 외래키가 기본키의 일부가 될 수 있다.

지금까지 관계 데이터베이스의 키에 대해 살펴보았다. 각 키의 포함 관계 및 정의를 요약하면 다음과 같다.

#### [키의 포함 관계]
<img src="https://github.com/silxbro/cs-study/assets/142463332/487fca89-14c8-4e3e-b88d-04c890f82940" width="420" height="180"/><br/>
<br/>
<br/>
## 2. 무결성 제약조건
데이터 무결성(integrity, 無缺性)은 데이터베이스에 저장된 데이터의 **일관성**과 **정확성**을 지키는 것을 말한다.
일관성과 정확성을 잃어버린 데이터베이스는 정보로서의 가치에 심각한 문제가 있는 것이다.
일관성과 정확성을 가지고 구축된 데이터베이스가 계속해서 무결성을 유지하려면 튜플의 삽입, 삭제, 수정 시 데이터의 제약조건 준수 여부를 확인하여야 한다.
- 마당서점 관리자가 재고가 없는 도서를 필요없는 데이터라고 판단하여 도서 릴레이션에서 삭제하면 어떻게 될까?
  이 경우 사장이 관리자에게 도서별 주문 내역을 요구하면, 관리자는 주문 릴레이션에서 주문 내역을 찾을 수 없다.
  왜냐하면 도서 릴레이션에서 재고가 없는 도서를 삭제해버렸기 때문에 주문 릴레이션의 도서번호를 통하여 도서 릴레이션을 아무리 조회해도 어떤 도서인지 알 수 없다.
  이와 비슷하게 학교에서 학생이 졸업했다고 하여 학생 정보를 삭제해버린다면 성적 및 수강 등 모든 관련 자료에 문제가 발생할 것이다.

실제 데이터의 삽입, 삭제, 수정에 관련된 문제는 응용 프로그램 개발 단계에서 프로그래머가 일일이 처리할 수 있다.
그러나 모든 경우를 감안하여 프로그램을 작성하기도 어렵고 향후 유지하기도 어렵다.
이 경우 데이터의 삽입, 삭제, 수정 시 필요한 기본적인 제약조건을 DBMS가 알아서 지켜준다면 프로그래머의 부담을 줄일 수 있다.
프로그래머는 데이터 변동에 따른 대응에 필요 이상의 시간을 투자하지 않고 프로그래밍에 집중할 수 있고, 소프트웨어의 성능 및 데이터의 신뢰성 향상에도 큰 도움을 줄 수 있다.

무결성 제약조건에는 튜플에 삽입 가능한 데이터의 값을 제한하는 도메인 무결성 제약조건과 관계 데이터 모델의 핵심인 관계 표현을 위한 개체 무결성 제약조건,
참조 무결성 제약조건이 있다.

### 🔳 도메인 무결성 제약조건
도메인 무결성 제약조건(domain integrity constraint)은 도메인 제약(domain constraint)이라고도 하며, 릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다는 조건이다.
- 주문 릴레이션에서 주문일자는 날짜 데이터만 사용해야 한다. 만약 영문자 등의 다른 자료형을 사용한다면 자료의 저장 및 검색에 큰 어려움이 따를 것이다.
  도메인 무결성 제약조건은 속성 값과 관련된 무결성으로, SQL 문에서 데이터 형식(type), 널(null/not null), 기본 값(default), 체크(check) 등을 사용하여 지정할 수 있다.
  일반적으로 프포그래밍 언어의 변수형 선언과 개념이 유사하다.

### 🔳 개체 무결성 제약조건
개체 무결성 제약조건(entity integrity constraint)은 기본키 제약(primary key constraint)이라고도 한다.
릴레이션은 기본키를 지정하고 그에 따른 무결성 원칙 즉, 기본키는 NULL 값을 가져서는 안 되며 릴레이션 내에 오직 하나의 값만 존재해야 한다는 조건이다.
개체 무결성 제약조건은 참조 무결성 제약조건과 함께 관계 데이터 모델의 핵심 개념이다.
- 마당서점 데이터베이스의 경우 고객 릴레이션은 고객번호, 도서 릴레이션은 도서번호, 주문 릴레이션은 주문번호가 기본키로 선언되었고 각각의 기본키는 NULL 값 없이 유일한
  값을 가지므로 개체 무결성 제약조건을 지키고 있다.

### 🔳 참조 무결성 제약조건
참조 무결성 제약조건(referential integrity constraint)은 외래키 제약(foreign key constraint)이라고도 한다. 릴레이션 간의 참조 관계를 선언하는 제약조건이다.
일반적으로 참조되는(제공하는) 릴레이션을 부모(parent) 릴레이션, 참조하는(제공받는) 릴레이션을 자식(child) 릴레이션이라고 한다.
참조 무결성 제약조건은 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 하며, 자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받는다는 것이다.
즉 부모 릴레이션의 도메인과 다른 값으로 삽입, 수정될 경우 거부되고, 반대로 자식 릴레이션에서 참조하고 있는 값을 부모 릴레이션에서 삭제하거나 다른 값으로 변경하려고 하면 거부된다.

#### [UNIQUE 제약조건(유일성 제약조건, 고유성 제약조건)]
실제 DBMS에서는 위에서 설명한 세 가지 무결성 제약조건과 함께 UNIQUE 제약조건(unique constraint)도 사용한다.
UNIQUE 제약조건은 속성의 모든 값들에 서로 같은 값이 없어야 한다는 것이다. 이는 릴레이션 내의 각각의 튜플을 유일하게 식별할 수 있는 속성들의 집합으로 볼 수 있다.
UNIQUE 제약조건은 기본키 제약과는 달리 NULL 값을 허용한다.

#### [제약조건의 정리]
<img src="https://github.com/silxbro/cs-study/assets/142463332/f67042a9-3fcd-43b8-a282-8dc3c4dcc821" width="650" height="350"/><br/>
<br/>
<br/>
## 3. 무결성 제약조건의 수행
릴레이션은 데이터의 변경이 일어날 때 제약조건에 위배될 수 있다. 따라서 **제약조건의 준수 여부는 데이터의 변경(삽입, 수정, 삭제)이 있을 때마다 확인**해야 한다.<br/>
예를 들어 기존의 기본키와 같은 값을 가진 튜플을 삽입하거나, 기존의 기본키 값을 다른 튜플의 기본키와 같은 값으로 변경한다면 그 연산은 거부된다.
또 부모 릴레이션에서 튜플을 삭제할 경우 자식 릴레이션도 같이 처리를 해야 한다.

각각의 제약조건에 대해 데이터의 변경이 일어나면 어떻게 수행되는지 살펴보자.

### 개체 무결성 제약조건
관계 데이터베이스 시스템에서 DBMS는 튜플을 삽입하거나 수정할 때마다 개체 무결성 제약조건을 지키는지 확인한다. 즉 기본키 값이 유일한지, NULL 값이 아닌지를 검사한다.
만약 조건에 맞지 않으면 삽입 연산을 거부하고 오류 메시지를 보낸다.

아래의 학생 릴레이션에서 학번은 기본키로 개체 무결성 제약조건을 지키고 있다.

#### [학생 릴레이션]
|학번|이름|학과코드|
|501|박지성|1001|
|401|김연아|2001|
|402|장미란|2001|
|502|추신수|1001|

#### 🔳 삽입
새로운 학생이 입학하였다. 새로운 튜플 (501, 남슬찬, 1001)이 삽입되는 과정을 살펴보자.
DBMS는 도메인 무결성 제약조건을 확인한 후 개체 무결성 제약조건을 수행하기 위해 학생 릴레이션을 살펴본다.
그런데 기본키인 학번에 이미 '501'이 존재하는 것을 발견하고 삽입을 거부한다.
또 다른 튜플 (NULL, 남슬찬, 1001)의 삽입 역시 기본키가 NULL이기 때문에 기존 튜플을 검색할 필요도 없이 거부한다.

#### 🔳 수정
수정 연산 역시 삽입 연산과 동일한 제약에 따라 처리된다. 학번 '501'을 '502'로 수정하려고 한다면 DBMS는 동일한 값이 존재하는지 검색한 후 수정을 거부한다.

#### 🔳 삭제
특별한 확인이 필요하지 않으며 즉시 수행한다. 단, 참조 무결성 제약조건에 의하여 학생 릴레이션의 기본키를 다른 릴레이션에서 외래키로 참조하고 있으면 바로 삭제하지 않는다.

### 참조 무결성 제약조건
참조 무결성 제약조건은 개체 무결성 제약조건과 달리 단일 릴레이션에 대한 내용이 아니다.
따라서 참조 무결성 제약조건을 준수하기 위해서는 두 릴레이션 간의 참조 관계에 따라 좀 더 복잡한 처리를 수행해야 한다.
부모 릴레이션(기본키가 참조되는 릴레이션)과 자식 릴레이션(기본키를 참조하는 릴레이션)의 관계를 학생관리 데이터베이스를 통해 살펴보자.
학과 릴레이션이 부모 릴레이션이고, 학생 릴레이션이 자식 릴레이션이다.

#### [학생관리 데이터베이스]
<img src="https://github.com/silxbro/cs-study/assets/142463332/b6a6babe-8e82-4035-9468-cdb751901f2e" width="380" height="180"/><br/>

#### 🔳 삽입
학생 릴레이션에 새로운 튜플 (601, 박세리, 3001)이 삽입되는 과정을 살펴보자.
DBMS는 먼저 도메인 무결성 제약조건을 확인한 후 개체 무결성 제약조건에 위배되는 값이 없는지 확인한다. 이후 학과코드 값 3001이 학과 릴레이션의 기본키에 존재하는지 확인한다.
그런데 3001은 학과 릴레이션에 없으므로 삽입은 거부된다. 이 경우 학과 릴레이션에 새로운 튜플(3001, 수학과)를 삽입한 후 수행하면 정상적으로 진행된다.
참고로 학생 릴레이션 생성 시 외래키인 학과코드 속성에 NULL 값을 허용하였다면 학과코드 값이 없어도 삽입이 가능하다.

#### 🔳 삭제
삽입과는 반대로 자식 릴레이션에서 튜플이 삭제되는 경우 부모 릴레이션에는 아무런 영향을 주지 않으므로 바로 삭제가 가능하다.
그러나 부모 릴레이션에서 튜플이 삭제되는 경우에는 문제가 발생할 수 있다.
학과 릴레이션에서 체육학과를 삭제해야 한다면 DBMS는 우선 학과 릴레이션의 학과코드를 참조하고 있는 다른 릴레이션이 없는지 찾는다.
이 경우 학생 릴레이션의 (401, 김연아, 2001)과 (402, 장영란, 2001)이 참조하고 있으므로 문제가 생긴다. 이 문제에 대한 조치 방법으로 다음과 같은 네 가지를 고려할 수 있다.
- 즉시 작업을 중지
- 자식 릴레이션의 관련 튜플을 삭제
- 초기에 설정된 다른 어떤 값으로 변경
- NULL 값으로 설정

이와 같이 DBMS는 부모 릴레이션에서 튜플을 삭제할 때 참조 무결성 제약조건을 수행하기 위한 네 가지 옵션이 있다. 이는 제약조건 선언 시 자식 릴레이션에도 지정해주어야 한다.

#### [참조 무결성 제약조건의 옵션(부모 릴레이션에서 튜플을 삭제할 경우)]
|명령어|의미|예|
|:---|:---|:---|
|RESTRICTED|자식 릴레이션에서 참조하고 있을 경우 부모 릴레이션의 삭제 작업을 거부함|학과 릴레이션의 튜플 삭제 거부|
|CASCADE|자식 릴레이션의 관련 튜플을 같이 삭제함|학생 릴레이션의 관련 튜플을 삭제|
|DEFAULT|자식 릴레이션의 관련 튜플을 미리 설정해둔 값으로 변경함|학생 릴레시연의 학과가 다른 학과로 자동 배정정|
|NULL|자식 릴레이션의 관련 튜플을 NULL 값으로 설정함(NULL 값을 허가한 경우)|학생 릴레이션의 학과가 NULL 값으로 변경|
- 제약조건의 옵션은 실제 DBMS별로 다른 용어를 사용하거나 경우에 따라 추가되거나 삭제된 형태로 제공된다.

#### 🔳 수정
수정은 삭제와 삽입 명령이 연속해서 수행된다고 보면 된다. 부모 릴레이션의 수정이 일어날 경우 삭제 옵션에 따라 처리된 후 문제가 없으면 다시 삽입 제약조건에 따라 처리된다.
학과 릴레이션의 학과코드 '1001'을 'A001'로 수정할 경우, 삭제 옵션에 따라(옵션이 RESTRICTED인 경우는 작업 중지) 자식 릴레이션의 관련 튜플을 처리한 후,
삽입 제약조건에 따라 학과 릴레이션에 삽입한다.